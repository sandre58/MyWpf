name: Release - Publish Package

on:
  push:
    tags:
      - '*/v*'  # Matches tags like MyNet.Utilities/v1.2.3
  repository_dispatch:
    types: [tag_created]  # Triggered by tag.yml workflow

permissions:
  contents: write      # Required to create releases
  packages: write      # Required to publish to GitHub Packages

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  detect-project-type:
    runs-on: ubuntu-latest
    outputs:
      project_name: ${{ steps.parse-tag.outputs.project_name }}
      version: ${{ steps.parse-tag.outputs.version }}
      is_wpf: ${{ steps.check-type.outputs.is_wpf }}
      project_path: ${{ steps.check-type.outputs.project_path }}
      project_dir: ${{ steps.check-type.outputs.project_dir }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse tag
        id: parse-tag
        run: |
          # Handle both push tag events and repository_dispatch events
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            tag="${{ github.event.client_payload.tag }}"
            project_name="${{ github.event.client_payload.project }}"
            version="${{ github.event.client_payload.version }}"
            echo "From repository_dispatch:"
            echo "Project: $project_name"
            echo "Version: $version"
            echo "Tag: $tag"
          else
            tag="${{ github.ref_name }}"
            echo "From push event - Full tag: $tag"
            
            # Extract project name and version from tag (format: ProjectName/vX.Y.Z)
            if [[ "$tag" =~ ^(.+)/v(.+)$ ]]; then
              project_name="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              
              echo "Project: $project_name"
              echo "Version: $version"
            else
              echo "Invalid tag format: $tag"
              echo "Expected format: ProjectName/vX.Y.Z"
              echo "tag_valid=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
          
          echo "project_name=$project_name" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "tag_valid=true" >> $GITHUB_OUTPUT

      - name: Find and check project type
        id: check-type
        if: steps.parse-tag.outputs.tag_valid == 'true'
        run: |
          project_name="${{ steps.parse-tag.outputs.project_name }}"
          
          # Search for the project file
          project_file=$(find src -name "$project_name.csproj" -type f | head -n1)
          
          if [ -z "$project_file" ]; then
            echo "Project file not found for: $project_name"
            exit 1
          fi
          
          echo "Found project file: $project_file"
          echo "project_path=$project_file" >> $GITHUB_OUTPUT

          # Get the directory
          project_dir=$(dirname "$project_file")
          echo "project_dir=$project_dir" >> $GITHUB_OUTPUT
          
          # Check if it's a WPF project
          if grep -q "Wpf" "$project_file" || [[ "$project_file" == *"/Wpf/"* ]]; then
            echo "This is a WPF project"
            echo "is_wpf=true" >> $GITHUB_OUTPUT
          else
            echo "This is a core/.NET project"
            echo "is_wpf=false" >> $GITHUB_OUTPUT
          fi

  # Job for WPF projects (Windows runner)
  publish-wpf:
    runs-on: windows-latest
    needs: detect-project-type
    if: needs.detect-project-type.outputs.is_wpf == 'true'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            10.0.x
            9.0.x
            8.0.x

      - name: Restore dependencies
        run: dotnet restore "${{ needs.detect-project-type.outputs.project_path }}"

      - name: Build and pack WPF project
        run: |
          $projectPath = "${{ needs.detect-project-type.outputs.project_path }}"
          $version = "${{ needs.detect-project-type.outputs.version }}"
          
          Write-Host "Building WPF project: $projectPath"
          
          dotnet pack "$projectPath" `
            --configuration Release `
            --output ./packages `
            -p:PackageVersion=$version `
            --include-symbols

      - name: Upload WPF packages
        uses: actions/upload-artifact@v4
        with:
          name: wpf-packages
          path: packages/*.nupkg

  # Job for Core/.NET projects (Linux runner)
  publish-core:
    runs-on: ubuntu-latest
    needs: detect-project-type
    if: needs.detect-project-type.outputs.is_wpf == 'false'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            10.0.x
            9.0.x
            8.0.x

      - name: Restore dependencies
        run: dotnet restore "${{ needs.detect-project-type.outputs.project_path }}"

      - name: Build and pack core project
        run: |
          project_path="${{ needs.detect-project-type.outputs.project_path }}"
          version="${{ needs.detect-project-type.outputs.version }}"
          
          echo "Building core project: $project_path"
          
          dotnet pack "$project_path" \
            --configuration Release \
            --output ./packages \
            -p:PackageVersion=$version \
            --include-symbols

      - name: Upload core packages
        uses: actions/upload-artifact@v4
        with:
          name: core-packages
          path: packages/*.nupkg

  # Job for publishing to NuGet (runs after build jobs)
  publish-to-nuget:
    runs-on: ubuntu-latest
    needs: [detect-project-type, publish-wpf, publish-core]
    if: always() && (needs.publish-wpf.result == 'success' || needs.publish-core.result == 'success')
    
    steps:
      - name: Download packages
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Publish to NuGet
        run: |
          echo "Publishing packages to NuGet..."
          
          # Find all .nupkg files (excluding .symbols.nupkg)
          find artifacts -name "*.nupkg" -not -name "*.symbols.nupkg" | while read package; do
            echo "Publishing: $package"
            
            if [ -n "${{ secrets.NUGET_API_KEY }}" ]; then
              dotnet nuget push "$package" \
                --api-key "${{ secrets.NUGET_API_KEY }}" \
                --source "https://api.nuget.org/v3/index.json" \
                --skip-duplicate
            else
              echo "NUGET_API_KEY not found, skipping publication"
            fi
          done

  # Job for creating GitHub release
  create-release:
    runs-on: ubuntu-latest
    needs: [detect-project-type, publish-to-nuget]
    if: always() && needs.publish-to-nuget.result == 'success'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install git-chglog
        run: |
          echo "Installing git-chglog..."
          wget -O git-chglog.tar.gz https://github.com/git-chglog/git-chglog/releases/download/v0.15.4/git-chglog_0.15.4_linux_amd64.tar.gz
          tar -xzf git-chglog.tar.gz
          sudo mv git-chglog /usr/local/bin/
          chmod +x /usr/local/bin/git-chglog
          git-chglog --version

      - name: Update git-chglog configs for project
        run: |
          project_name="${{ needs.detect-project-type.outputs.project_name }}"
          
          echo "Updating git-chglog configurations for $project_name..."
          
          # Update the title in both config files to match the current project
          sed -i "s/title: CHANGELOG/title: $project_name/" .chglog/config.yml
          sed -i "s/title: CHANGELOG/title: $project_name/" .chglog/release-config.yml
          
          echo "Configurations updated for project: $project_name"

      - name: Generate release changelog
        id: changelog
        run: |
          project_name="${{ needs.detect-project-type.outputs.project_name }}"
          current_tag="${{ github.ref_name }}"
          project_dir="${{ needs.detect-project-type.outputs.project_dir }}"
          
          echo "Generating release changelog for $project_name using git-chglog..."
          
          # Find previous tag for this project
          previous_tag=$(git tag -l "$project_name/v*" --sort=-version:refname | grep -v "^$current_tag$" | head -n1)
          
          if [ -z "$previous_tag" ]; then
            echo "No previous tag found, generating changelog from beginning"
            # Generate changelog for current tag only (all history)
            git-chglog --config .github/.chglog/release-config.yml --path "$project_dir" --tag-filter-pattern "$project_name/v*" "$current_tag" > RELEASE_CHANGELOG.md
          else
            echo "Previous tag: $previous_tag"
            # Generate changelog between previous and current tag (for release)
            git-chglog --config .github/.chglog/release-config.yml --path "$project_dir" --tag-filter-pattern "$project_name/v*" "$previous_tag".."$current_tag" > RELEASE_CHANGELOG.md
          fi
          
          echo "Release changelog generated:"
          cat RELEASE_CHANGELOG.md

      - name: Update project CHANGELOG.md
        run: |
          project_name="${{ needs.detect-project-type.outputs.project_name }}"
          current_tag="${{ github.ref_name }}"
          project_dir="${{ needs.detect-project-type.outputs.project_dir }}"
          project_changelog="$project_dir/CHANGELOG.md"
          
          echo "Updating permanent CHANGELOG.md for $project_name..."
          
          # Generate complete changelog for all versions of this project
          git-chglog --config .chglog/config.yml --path "$project_dir" --tag-filter-pattern "$project_name/v*" > "$project_changelog"
          
          echo "Permanent CHANGELOG.md updated at: $project_changelog"
          echo "Content preview:"
          head -30 "$project_changelog"

      - name: Commit updated CHANGELOG.md
        run: |
          project_dir="${{ needs.detect-project-type.outputs.project_dir }}"
          project_changelog="$project_dir/CHANGELOG.md"
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add and commit the updated CHANGELOG.md
          git add "$project_changelog"
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to CHANGELOG.md, skipping commit"
          else
            git commit -m "docs(${{ needs.detect-project-type.outputs.project_name }}): update CHANGELOG.md for v${{ needs.detect-project-type.outputs.version }}

            Auto-generated by GitHub Actions for release ${{ github.ref_name }}"
            
            # Push the changes
            git push origin HEAD:main
            
            echo "CHANGELOG.md committed and pushed to main branch"
          fi

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.detect-project-type.outputs.project_name }}/v${{ needs.detect-project-type.outputs.version }}
          release_name: ${{ needs.detect-project-type.outputs.project_name }} v${{ needs.detect-project-type.outputs.version }}
          body: |
            Release of ${{ needs.detect-project-type.outputs.project_name }} version ${{ needs.detect-project-type.outputs.version }}
            
            This release was automatically created by GitHub Actions.
          draft: false
          prerelease: false
